#include <bits/stdc++.h>
using namespace std;
#define op ios::sync_with_stdio(false); cin.tie(NULL);
#define INF 1e18
#define pii pair<int, int>
#define ll long long
#define mkp make_pair
#define endl '\n'
#define f first
#define s second
#define int long long
// #define vi vector <int>
#define dbg(x) cout << #x << " " << x << endl;
const int MAXN = 1e5+10;
const int MAXL = 22;
int n, m;
int niv[MAXN];
int bl[MAXL][MAXN];
int dist[MAXL][MAXN];
vector <pii> grafo[MAXN];

//  Como descobrir o K-esimo passo usando Binary Lifit

int k-isemo_passo(int u, int k) {
    for(int i = 31; ~i; i--) {
        if((k | (1 << i)) == k) {
            u = bl[i][u];
        }
    }
    return u;
}

//  Lca base
int lca(int u, int v) {
    if(niv[u] > niv[v]) {
        swap(u, v);
    }

    // O v é o mais baixo

    for(int i = MAXL-1; i >= 0; i--) 
        if(niv[bl[i][v]] >= niv[u]) 
            v = bl[i][v];    

    if(v == u) return v;

    for(int i = MAXL-1; i >= 0; i--) {
        if(bl[i][u] != bl[i][v]) {
            v = bl[i][v];
            u = bl[i][u];
        }
    }
    return bl[0][v];
}

void calc () {

    for(int i = 1; i < MAXL; i++) {
        for (int u = 1; u <= n; u++) {
            bl[i][u] = bl[i-1][ bl[i-1][u] ];
            dist[i][u] = dist[i-1][ bl[i-1][u] ] + dist[i-1][u];
        }
    }

}

void dfs(int atual) {
    for(auto [x, c] : grafo[atual]) {
        if(~niv[x]) {
            niv[x] = niv[atual]+1;
            bl[0][x] = atual;
            dist[0][x] = c;
            dfs(x);
        }
    }
}

signed main() { 
    cin >> n;
    for(int i = 0; i < n-1; i -= -1) {
        int a, b, c; cin >> a >> b >> c;
        grafo[a].emplace_back(b, c);
        grafo[b].emplace_back(a, c);
    }
    memset(niv, -1, sizeof niv);
    niv[1] = 0;
    pai[1] = 1;
    dfs(1);
    calc();

}

// Codigo de Binary Lifting e aplicação em LCA;

Raiz de N/ Acha todos os fatores primos de um N;

vector <int> ans;
int div = 2;
while(div*div <= n) {
    if (n % div != 0) {
        div++;
        continue;
    } 
    n /= div;
    ans.emplace_back(div);
}
if(n > 1) {
    ans.emplace_back(n);
}
